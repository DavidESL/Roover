#include <Arduino.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <freertos/semphr.h>
#include <Wire.h>
#include <VL53L0X.h>



// -------------------- PINES --------------------
#define MOTOR_IN1 4
#define MOTOR_OUT1 15
#define MOTOR_IN2 14
#define MOTOR_OUT2 13
#define SEN1 5
#define SEN2 18
#define SEN3 19
#define SEN4 21 //quitar sensor 4
#define ENA 22
#define ENB 23

const int S0   = 25;
const int S1   = 26;
const int S2   = 27;
const int S3   = 32;
const int SOUT = 33;

// define variables for pulses
unsigned long red; unsigned long Rn;
unsigned long blue; unsigned long Bn;
unsigned long green; unsigned long Gn;
unsigned long clear;

// -------------------- VARIABLES --------------------
volatile int sread1 = 0;
volatile int sread2 = 0;
volatile int sread3 = 0;
volatile int sread4 = 0;
volatile int fase = 1;
int velocidad = 0;

VL53L0X sensor;

SemaphoreHandle_t xMotorSemaphore;

// -------------------- PROTOTIPOS --------------------
void taskControlMotor(void *pvParameters);
void taskRGB(void *pvParameters);

// -------------------- FUNCIONES DE MOVIMIENTO --------------------
void adelante() {
  digitalWrite(MOTOR_IN1, LOW);
  digitalWrite(MOTOR_OUT1, HIGH);
  digitalWrite(MOTOR_IN2, LOW);
  digitalWrite(MOTOR_OUT2, HIGH);
  analogWrite(ENA, 128);
  analogWrite(ENB, 128);
}

void atras() {
  digitalWrite(MOTOR_IN1, HIGH);
  digitalWrite(MOTOR_OUT1, LOW);
  digitalWrite(MOTOR_IN2, HIGH);
  digitalWrite(MOTOR_OUT2, LOW);
  analogWrite(ENA, 128);
  analogWrite(ENB, 128);
}

void vuelta() {
  digitalWrite(MOTOR_IN1, HIGH);
  digitalWrite(MOTOR_OUT1, LOW);
  digitalWrite(MOTOR_IN2, LOW);
  digitalWrite(MOTOR_OUT2, HIGH);
  analogWrite(ENA, 130);
  analogWrite(ENB, 200);
}

void adelante_tof() {
  int distancia = sensor.readRangeContinuousMillimeters();
  if(sensor.timeoutOccurred() == false) {
    Serial.print("Distancia: ");
    Serial.println(distancia);

    // rango ejemplo: 50mm a 500mm
    distancia = constrain(distancia, 50, 500); //constrain(x, a, b) = x = valor original, a = min, b = max, si x se sale corrige
    velocidad = map(distancia, 50, 500, 0, 255);
    //map(x, in_min, in_max, out_min, out_max), funciona como un cambio de escala
    //pasara una distancia aproximada a un valor de velocidad

  Serial.print("Velocidad: ");
  Serial.println(velocidad);
  digitalWrite(MOTOR_IN1, HIGH);
  digitalWrite(MOTOR_OUT1, LOW);
  digitalWrite(MOTOR_IN2, LOW);
  digitalWrite(MOTOR_OUT2, HIGH);
  analogWrite(ENA, velocidad);
  analogWrite(ENB, velocidad);
}
}

// -------------------- SETUP --------------------
void setup() {

  pinMode(MOTOR_IN1, OUTPUT);
  pinMode(MOTOR_OUT1, OUTPUT);
  pinMode(MOTOR_IN2, OUTPUT);
  pinMode(MOTOR_OUT2, OUTPUT);
  pinMode(ENA, OUTPUT);
  pinMode(ENB, OUTPUT);

  pinMode(SEN1, INPUT);
  pinMode(SEN2, INPUT);
  pinMode(SEN3, INPUT);
  pinMode(SEN4, INPUT);


  pinMode(S0,OUTPUT);
  pinMode(S1,OUTPUT);
  pinMode(S2,OUTPUT);
  pinMode(S3,OUTPUT);
  pinMode(SOUT,INPUT);


  digitalWrite(S0,HIGH);
  digitalWrite(S1,LOW);

  Wire.begin();

  sensor.init();
  sensor.startContinuous(0);

  xMotorSemaphore = xSemaphoreCreateMutex();


  // Tarea sensores de l√≠nea (prioridad mayor)
  xTaskCreate(taskControlMotor, "ControlMotor", 5000, NULL, 2, NULL);

  // Tarea futura RGB (prioridad menor por ahora)
  xTaskCreate(taskRGB, "ControlRGB", 5000, NULL, 1, NULL);

  delay(2000);
}

void loop() {
  vTaskDelay(portMAX_DELAY);
}

// -------------------- TAREA 1: CONTROL DE LINEA --------------------
void taskControlMotor(void *pvParameters) {

  while (1) {

    sread1 = digitalRead(SEN1);
    sread2 = digitalRead(SEN2);
    sread3 = digitalRead(SEN3);
    sread4 = digitalRead(SEN4);

    if (sread1 == 1 || sread2 == 1) {

      if (xSemaphoreTake(xMotorSemaphore, pdMS_TO_TICKS(100)) == pdTRUE) {
        atras();
        xSemaphoreGive(xMotorSemaphore);
      }

      vTaskDelay(pdMS_TO_TICKS(300));

      if (xSemaphoreTake(xMotorSemaphore, pdMS_TO_TICKS(100)) == pdTRUE) {
        vuelta();
        xSemaphoreGive(xMotorSemaphore);
      }

      vTaskDelay(pdMS_TO_TICKS(600));
    }
    else {
      if (xSemaphoreTake(xMotorSemaphore, pdMS_TO_TICKS(10)) == pdTRUE) {
        adelante();
        adelante_tof();
        xSemaphoreGive(xMotorSemaphore);
      }
    }

    vTaskDelay(pdMS_TO_TICKS(20));
  }
}

// -------------------- TAREA 2: DETECCION RGB (FUTURA) --------------------
void taskRGB(void *pvParameters) {

  while (1) {

    // =========================================
    // Aqui va la tarea de deteccion RGB
    // =========================================

  // clear
  digitalWrite(S2,HIGH);
  digitalWrite(S3,LOW);
  // red
  digitalWrite(S2,LOW);
  digitalWrite(S3,LOW);
  // green
  digitalWrite(S2,HIGH);
  digitalWrite(S3,HIGH);
  // blue
  digitalWrite(S2,LOW);
  digitalWrite(S3,HIGH);

  red   = pulseIn(SOUT, HIGH, 30000);
  green = pulseIn(SOUT, HIGH, 30000);
  blue  = pulseIn(SOUT, HIGH, 30000);
  clear = pulseIn(SOUT, HIGH, 30000);

  float sum = red + green + blue;

  Rn = ((red*100)   / sum);
  Gn = ((green*100) / sum);
  Bn = ((blue*100)  / sum);

  switch (fase) {
    case 1:
      if (red < blue && red <green){ 
        Serial.print(" | Red: "); Serial.print(red);
        if (xSemaphoreTake(xMotorSemaphore, pdMS_TO_TICKS(100)) == pdTRUE) {
          atras();
          xSemaphoreGive(xMotorSemaphore);
          }
          vTaskDelay(pdMS_TO_TICKS(300));
          if (xSemaphoreTake(xMotorSemaphore, pdMS_TO_TICKS(100)) == pdTRUE) {
            vuelta();
            xSemaphoreGive(xMotorSemaphore);
          }
          vTaskDelay(pdMS_TO_TICKS(600));
      }

      else if (blue > red && blue > green){
        Serial.print(" | Yellow: ");
        if (xSemaphoreTake(xMotorSemaphore, pdMS_TO_TICKS(100)) == pdTRUE) {
          //led_amarillo();
          //delay(600);
          //atras();
          //delay(600);
          fase = 2;
          xSemaphoreGive(xMotorSemaphore);
        }
      }
      break;
    case 2:
      //led();
      //delay(500);
      if (red < blue && red <green){ 
        Serial.print(" | Red: "); Serial.print(red);
        if (xSemaphoreTake(xMotorSemaphore, pdMS_TO_TICKS(100)) == pdTRUE) {
          vuelta();
          xSemaphoreGive(xMotorSemaphore);
          }
          vTaskDelay(pdMS_TO_TICKS(1000));
          //led();
          //delay(500);
          fase = 3;

        }
        if (blue < red && blue < green){ 
        Serial.print(" | Blue: "); Serial.print(blue);
          if (xSemaphoreTake(xMotorSemaphore, pdMS_TO_TICKS(100)) == pdTRUE) {
            atras();
            xSemaphoreGive(xMotorSemaphore);
            }
            vTaskDelay(pdMS_TO_TICKS(300));
            if (xSemaphoreTake(xMotorSemaphore, pdMS_TO_TICKS(100)) == pdTRUE) {
              vuelta();
              xSemaphoreGive(xMotorSemaphore);
            }
            vTaskDelay(pdMS_TO_TICKS(600));
        }
        break;
    case 3:
      if (blue < red && blue < green){ 
        Serial.print(" | Blue: "); Serial.print(blue);
        if (xSemaphoreTake(xMotorSemaphore, pdMS_TO_TICKS(100)) == pdTRUE) {
          //led();
          //delay(300);
          xSemaphoreGive(xMotorSemaphore);
          }
        vTaskDelay(pdMS_TO_TICKS(300));
        fase = 4;
      }
      break;
    default:
            printf("Opcion no valida\n");
    }


  vTaskDelay(pdMS_TO_TICKS(50));
  }
}
